/*
 * Copyright (C) Huawei Technologies Co., Ltd. 2026. All rights reserved.
 * SPDX-License-Identifier: MIT
 */
/**
 * @file bm_autogen.h
 * @brief This program is autogenerated from syycall traces
 *
 */

#include <CSB/bm_target.h>
#include <CSB/bm_helper.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <dirent.h>
#include <errno.h>
#include <sys/mman.h>

#define BM_CTX_TID (ctx->tid)

#define NOP_PER_OP   1
#define MAX_NAME_LEN 20U
#define NUM_SYSCALLS 1

const char *op_name_tbl[1];

struct thread_ctx_s {
    size_t tid;
    size_t iteration;
    bool aggregation_threads;
    char *tmpdir_min_mysql_newfstatat_openat_0_1_prog;
    int dirfd_min_mysql_newfstatat_openat_0_1_prog;
    int num_succeeded_min_mysql_newfstatat_openat_0_1_prog;
    int num_failed_min_mysql_newfstatat_openat_0_1_prog;
    uintptr_t mmap_offsets_min_mysql_newfstatat_openat_0_1_prog;
};

#define REPEAT_NUM 1

#define PTR_OFFSET                                                             \
    (ctx->mmap_offsets_min_mysql_newfstatat_openat_0_1_prog - MMAP_OFFSET)
#define UNIQUE_ID min_mysql_newfstatat_openat_0_1_prog
#include "syz/min_mysql_newfstatat_openat_0_1.h"

static inline void
_mkdir_min_mysql_newfstatat_openat_0_1_prog(thread_ctx_t *ctx, const char *dir)
{
    char tmp[256];
    char *p = NULL;
    size_t len;

    snprintf(tmp, sizeof(tmp), "%s", dir);
    len = strlen(tmp);
    if (tmp[len - 1] == '/')
        tmp[len - 1] = 0;
    for (p = tmp + 1; *p; p++)
        if (*p == '/') {
            *p = 0;
            mkdirat(ctx->dirfd_min_mysql_newfstatat_openat_0_1_prog, tmp,
                    S_IRWXU);
            *p = '/';
        }
    mkdirat(ctx->dirfd_min_mysql_newfstatat_openat_0_1_prog, tmp, S_IRWXU);
}

static inline void
init_subdirs_min_mysql_newfstatat_openat_0_1_prog(thread_ctx_t *ctx)
{
    for (int i = 0; i < num_subdirs_min_mysql_newfstatat_openat_0_1_prog; i++) {
        _mkdir_min_mysql_newfstatat_openat_0_1_prog(
            ctx, subdirs_min_mysql_newfstatat_openat_0_1_prog[i]);
    }
}

static void __attribute__((noinline))
remove_tmp_dir_min_mysql_newfstatat_openat_0_1_prog(const char *dir);
static inline void
rm_tmpdir_min_mysql_newfstatat_openat_0_1_prog(thread_ctx_t *ctx)
{
    remove_tmp_dir_min_mysql_newfstatat_openat_0_1_prog(
        ctx->tmpdir_min_mysql_newfstatat_openat_0_1_prog);
}

static inline char *
bm_target_get_name(void)
{
    return "min_mysql_newfstatat_openat_0_1";
}

static inline size_t
bm_target_op_count(void)
{
    return NUM_SYSCALLS;
}

static inline void
bm_target_get_op_name(char *out_str, const size_t len, size_t op_id)
{
    assert(len >= MAX_NAME_LEN && "output buffer too small");
    assert(op_id == 0);
    snprintf(out_str, len, "%s", op_name_tbl[op_id]);
    // V_UNUSED(len, op_id);
}

static inline void
bm_target_init(size_t init_size, size_t num_threads)
{
    V_UNUSED(init_size, num_threads);
    op_name_tbl[0] = "min_mysql_newfstatat_openat_0_1";
}

static inline void
bm_target_reg(thread_ctx_t *ctx, size_t tid)
{
    assert(ctx);
    ctx->tid                 = tid;
    ctx->aggregation_threads = false;

    char *tmpdir_template = NULL;

    int fd_trunc = 0;
    tmpdir_template =
        strdup("./syzkaller_min_mysql_newfstatat_openat_0_1.XXXXXX");
    ctx->tmpdir_min_mysql_newfstatat_openat_0_1_prog = mkdtemp(tmpdir_template);
    chmod(ctx->tmpdir_min_mysql_newfstatat_openat_0_1_prog,
          S_IRWXU | S_IRWXG | S_IRWXO);
    ctx->dirfd_min_mysql_newfstatat_openat_0_1_prog = open(
        ctx->tmpdir_min_mysql_newfstatat_openat_0_1_prog, O_DIRECTORY | O_PATH);
    init_subdirs_min_mysql_newfstatat_openat_0_1_prog(ctx);
    ctx->num_succeeded_min_mysql_newfstatat_openat_0_1_prog = 0;
    ctx->num_failed_min_mysql_newfstatat_openat_0_1_prog    = 0;

    assert(num_filenames_min_mysql_newfstatat_openat_0_1_prog ==
           num_filesizes_min_mysql_newfstatat_openat_0_1_prog);

    for (int i = 0; i < num_filenames_min_mysql_newfstatat_openat_0_1_prog;
         i++) {
        fd_trunc = openat(ctx->dirfd_min_mysql_newfstatat_openat_0_1_prog,
                          filenames_min_mysql_newfstatat_openat_0_1_prog[i],
                          O_RDWR | O_CREAT, S_IRWXU | S_IRWXG | S_IRWXO);
        // assert(fd_trunc > 0 && "Could not open file at thread registration");
        if (fd_trunc < 0)
            continue;
        int ret_ft = ftruncate(
            fd_trunc, filesizes_min_mysql_newfstatat_openat_0_1_prog[i]);
        (void)ret_ft;
        assert(ret_ft == 0);
        close(fd_trunc);
        fd_trunc = 0;
    }

    ctx->mmap_offsets_min_mysql_newfstatat_openat_0_1_prog =
        (uintptr_t)(void *)mmap(NULL, MMAP_LENGTH,
                                PROT_WRITE | PROT_READ | PROT_EXEC,
                                MAP_ANONYMOUS | MAP_PRIVATE, (intptr_t)-1, 0ul);
    if (ctx->mmap_offsets_min_mysql_newfstatat_openat_0_1_prog == -1) {
        perror("mmap from syzkaller failed");
        assert(0 && "mmap from syzkaller failed");
    }

    assert(ctx->mmap_offsets_min_mysql_newfstatat_openat_0_1_prog);

    // do one warmup iteration to allocate memory in mmap
    bm_dispatch_operation_min_mysql_newfstatat_openat_0_1_prog(ctx, 0);

    // reset statistics
    ctx->num_succeeded_min_mysql_newfstatat_openat_0_1_prog = 0;
    ctx->num_failed_min_mysql_newfstatat_openat_0_1_prog    = 0;
}

static inline void
bm_target_dereg(thread_ctx_t *ctx, size_t tid)
{
    // rm_tmpdir_min_mysql_newfstatat_openat_0_1_prog(ctx);
    free(ctx->tmpdir_min_mysql_newfstatat_openat_0_1_prog);
    ctx->tmpdir_min_mysql_newfstatat_openat_0_1_prog = NULL;

    V_UNUSED(ctx, tid);
}

static inline void
bm_target_destroy(size_t num_threads)
{
    V_UNUSED(num_threads);
}

static inline void
bm_target_extra_info(char *buf, size_t len)
{
    V_UNUSED(buf, len);
}

static inline bm_op_res_t
bm_dispatch_operation(thread_ctx_t *ctx, size_t op_id)
{
    bm_op_res_t res_all;
    res_all.op_count   = 0;
    res_all.succ_count = 0;
    bm_dispatch_operation_min_mysql_newfstatat_openat_0_1_prog(ctx, op_id);
    res_all.op_count +=
        ctx->num_succeeded_min_mysql_newfstatat_openat_0_1_prog +
        ctx->num_failed_min_mysql_newfstatat_openat_0_1_prog;
    res_all.succ_count +=
        ctx->num_succeeded_min_mysql_newfstatat_openat_0_1_prog;
    ctx->iteration++;
    return res_all;
}
